---
title: "sparseMatrix"
author: "Marine Marjou"
date: "28 août 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(Matrix)
library(microbenchmark)
```


# 1. Qu'est ce que c'est ?

Les matrices creuses ou *sparse matrix* sont des matrices qui contiennent beaucoup de zéros (ex: matrice d'adjacence, matrice diagonale, etc...). Ces matrices peuvent prendre beaucoup de places et il est donc judicieux d'utiliser des fonctions spéciales pour ce genre de matrice afin de les rendre plus *légères* : les valeurs nulles vont être remplacées par un point `.`.

# 2. Utilisation des matrices creuses

## 2.1 Avec le package `Matrix`

```{r}
m1 <- matrix(0, nrow = 1000, ncol = 1000)
m2 <- Matrix(0, nrow = 1000, ncol = 1000, sparse = TRUE)

m1[1:5, 1:5]
object.size(m1)
m2[1:5, 1:5]
object.size(m2)
```

Selon le type de données que l'on possède plusieurs stratégies de création de matrice creuse sont possibles :

### 2.1.1- Transformer à l'aide des fonctions `as` ou `Matrix`

```{r}
mat <- matrix(rbinom(10000, 1, 0.1), ncol = 100, nrow = 100)
object.size(mat)

mat_sparse <- as(mat, "sparseMatrix")
object.size(mat_sparse)

mat_sparse2 <- Matrix(mat, sparse = TRUE)
object.size(mat_sparse2)
```

Par défaut, lorsque l'on renseigne la classe `sparseMatrix` la compression se fera automatiquement par COLONNE, mais il est possible de choisir entre une compression par ligne ou par colonne avec les arguments suivant :

- par colonne avec `as(dt, "dgCMatrix")` 
- par ligne avec `as(dt, "dgRMatrix")`

Ce choix de compression peut s'avérer utile selon si on veut travailler par ligne ou par colonne.

Autre choix de compression :

Class | Compression | Type
------|-------------|----------------
ngeMatrix	|none	|logicals
dgeMatrix	|none	|real numbers
dgCMatrix	|compressed sparse column	|real numbers
dgRMatrix	|compressed sparse row	|real numbers
ngCMatrix	|compressed sparse column	|logicals
ngRMatrix	|compressed sparse row	|real numbers


### 2.1.2- Transformation avec un stockage en triplet avec `sparseMatrix`:

```{r}
# Génération de la matrice
k <- c(4,5,7,1,3,2,6)
i <- c(1,1,5,4,2,1,3)
j <- c(3,4,4,1,2,2,4)

my.matrix <- matrix(ncol=4, nrow = 5, 0)
s <- sapply(1:7, function(ii){
 my.matrix[i[ii], j[ii]] <<- k[ii]
 })

my.matrix
```
  
Avec :  
- i : indices des lignes  
- j : indices des colonnes  
- k : valeurs non-nulles  

```{r}
mat_sparse_triplet <- sparseMatrix(i = i, j = j, x = k)
object.size(mat_sparse3)
```

```{r}
mat_sparse4 <- as(my.matrix, "sparseMatrix")
object.size(mat_sparse4)

mat_sparse5 <- Matrix(my.matrix, sparse = TRUE)
object.size(mat_sparse5)
```

### 2.1.3 Enregistrer/charger une sparseMatrix

```{r eval=FALSE, include=TRUE}
writeMM(obj = mat_spars_triplet, file = "sparse_matrix.mtx")

sp_matrix_read <- readMM("sparse_matrix.mtx")
```


## 2.2 Avec le package `slam`

```{r}
library(slam)
slam.matrix <- simple_triplet_matrix(i = i, j = j, v = k)
# ou
slam.matrix <- as.simple_triplet_matrix(my.matrix)
object.size(slam.matrix)
```

Attention :
```{r}
slam.matrix
```
`slam` n'enregistre pas *la forme de la matrice* comme on a pu le voir avec `Matrix` mais l'ensemble du triplet renseigné dans la fonction :
```{r eval=FALSE, include=TRUE}
slam.matrix$i
slam.matrix$j
slam.matrix$v
```












